// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  // CRITICAL: Always keep provider as "postgresql" - changing to "sqlite" breaks Vercel deployments
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// RBAC Models (using String fields instead of enums for SQLite compatibility)
model User {
  id                String        @id @default(cuid())
  email             String        @unique
  name              String?
  password          String?       // Store hashed passwords
  globalRole        String        @default("USER") // "USER" | "SUPERUSER"
  defaultSurgeryId  String?
  defaultSurgery    Surgery?      @relation("DefaultSurgery", fields: [defaultSurgeryId], references: [id])
  memberships       UserSurgery[]
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  
  // Test user fields
  isTestUser        Boolean       @default(false)
  symptomUsageLimit Int?          // null = unlimited, number = limit
  symptomsUsed      Int           @default(0)
  
  // NextAuth.js fields
  emailVerified     DateTime?
  image             String?
  accounts          Account[]
  sessions          Session[]
}

model UserSurgery {
  id         String      @id @default(cuid())
  userId     String
  surgeryId  String
  role       String      @default("STANDARD") // "STANDARD" | "ADMIN"
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  surgery    Surgery     @relation("SurgeryUsers", fields: [surgeryId], references: [id], onDelete: Cascade)

  @@unique([userId, surgeryId])
}

// AgeGroup values: 'U5' | 'O5' | 'Adult'

model Surgery {
  id            String   @id @default(cuid())
  name          String   @unique
  slug          String?  @unique // Made optional for backward compatibility
  adminEmail    String?  @unique
  adminPassHash String?  // bcrypt hash; nullable until set
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // RBAC relationships
  users         UserSurgery[] @relation("SurgeryUsers")
  defaultUsers  User[]        @relation("DefaultSurgery")

  // Config
  enableDefaultHighRisk Boolean @default(true) // Enable/disable default high-risk buttons
  enableBuiltInHighlights Boolean @default(true) // Enable/disable built-in highlight rules
  highRiskLinks HighRiskLink[]
  defaultHighRiskButtons DefaultHighRiskButtonConfig[]
  highlightRules HighlightRule[]
  symptomOverrides SurgerySymptomOverride[]
  customSymptoms  SurgeryCustomSymptom[]
  suggestions   Suggestion[]
  events        EngagementEvent[]
}

model BaseSymptom {
  id               String   @id @default(cuid())
  slug             String   @unique
  name             String
  ageGroup         String   // 'U5' | 'O5' | 'Adult'
  briefInstruction String?
  highlightedText  String?
  instructions     String?  // Legacy markdown field for back-compat
  instructionsJson String?  // ProseMirror JSON (canonical format) - stored as string
  instructionsHtml String?  // HTML format with colour support
  linkToPage       String?
  variants         Json?    // Optional age/scenario-tailored advice variants
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  overrides SurgerySymptomOverride[]
  events    EngagementEvent[]

  // Effective index helpers:
  @@index([name])
  @@index([slug])
  @@index([ageGroup])
}

model SurgerySymptomOverride {
  id               String   @id @default(cuid())
  surgeryId        String
  baseSymptomId    String
  // Any field that, if non-null, overrides the base:
  name             String?
  ageGroup         String?  // 'U5' | 'O5' | 'Adult'
  briefInstruction String?
  highlightedText  String?
  instructions     String?  // Legacy markdown field for back-compat
  instructionsJson String?  // ProseMirror JSON (canonical format) - stored as string
  instructionsHtml String?  // HTML format with colour support
  linkToPage       String?
  // Soft delete: if true, this symptom is hidden for this surgery
  isHidden         Boolean  @default(false)

  surgery          Surgery     @relation(fields: [surgeryId], references: [id], onDelete: Cascade)
  baseSymptom      BaseSymptom @relation(fields: [baseSymptomId], references: [id], onDelete: Cascade)

  @@unique([surgeryId, baseSymptomId])
  @@index([surgeryId, baseSymptomId])
}

model SurgeryCustomSymptom {
  id               String   @id @default(cuid())
  surgeryId        String
  slug             String   // unique per surgery
  name             String
  ageGroup         String   // 'U5' | 'O5' | 'Adult'
  briefInstruction String?
  highlightedText  String?
  instructions     String?  // Legacy markdown field for back-compat
  instructionsJson String?  // ProseMirror JSON (canonical format) - stored as string
  instructionsHtml String?  // HTML format with colour support
  linkToPage       String?

  surgery          Surgery @relation(fields: [surgeryId], references: [id], onDelete: Cascade)

  @@unique([surgeryId, slug])
  @@index([surgeryId, slug])
  @@index([surgeryId, ageGroup])
}

model Suggestion {
  id         String   @id @default(cuid())
  surgeryId  String?
  baseId     String?      // optional link to the affected base symptom
  symptom    String       // captured as user typed/selected
  userEmail  String?
  text       String
  // TODO: Add these fields back when database schema is updated
  // status     String   @default("pending") // "pending" | "actioned" | "discarded"
  createdAt  DateTime @default(now())
  // updatedAt  DateTime @updatedAt
  surgery    Surgery? @relation(fields: [surgeryId], references: [id])
}

model EngagementEvent {
  id         String   @id @default(cuid())
  surgeryId  String?
  baseId     String
  userEmail  String?
  event      String    // "view_symptom"
  createdAt  DateTime @default(now())

  surgery Surgery?     @relation(fields: [surgeryId], references: [id])
  base    BaseSymptom @relation(fields: [baseId], references: [id], onDelete: Cascade)
}

model HighlightRule {
  id         String   @id @default(cuid())
  // If null => global rule (applies to all unless overridden/disabled per surgery later)
  surgeryId  String?
  phrase     String
  textColor  String   @default("#FFFFFF")
  bgColor    String   @default("#6A0DAD") // purple default
  isEnabled  Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  surgery    Surgery? @relation(fields: [surgeryId], references: [id], onDelete: Cascade)

  @@unique([surgeryId, phrase])
  @@index([surgeryId, phrase])
}

model HighRiskLink {
  id         String   @id @default(cuid())
  surgeryId  String
  label      String   // e.g., "Anaphylaxis", "Stroke"
  // Either link by slug or by id; slug is friendlier for admins:
  symptomSlug String?
  symptomId   String?

  orderIndex Int      @default(0)

  surgery    Surgery @relation(fields: [surgeryId], references: [id], onDelete: Cascade)
  // No explicit FK to Base/Custom because it can point to either via slug resolution.
  
  @@unique([surgeryId, label])
  @@index([surgeryId, orderIndex])
}

model DefaultHighRiskButtonConfig {
  id         String   @id @default(cuid())
  surgeryId  String
  buttonKey  String   // e.g., "anaphylaxis", "stroke", "chest-pain", "sepsis", "meningitis"
  label      String   // e.g., "Anaphylaxis", "Stroke"
  symptomSlug String   // e.g., "anaphylaxis", "stroke"
  isEnabled  Boolean  @default(true)
  orderIndex Int      @default(0)

  surgery    Surgery @relation(fields: [surgeryId], references: [id], onDelete: Cascade)
  
  @@unique([surgeryId, buttonKey])
  @@index([surgeryId, buttonKey])
}

// NextAuth.js models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
